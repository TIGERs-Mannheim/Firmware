:toc:

= Embedded Coding Workshop

== Project structure

This project contains code for TIGERs robots generation v2016 and v2019 and for the base station v2018.

Hardware maps to Eclipse projects as follows:

* Robot v2020: main2019, motor2019, ir2019
* Robot v2016: main2016
* Base station v2018: bs2018

v2020 robots have two sub-processor types. One for the front infrared barrier and array, contained in ir2019 project 
and one for each motor controller, contained in motor2019.

A brief overview of the folder structure under Firmware:

* src: application code
** bs2018: base station v2018
** ir2019: infrared barrier and array of v2020 robots
** main2016: main processor code v2016 robots
** main2019: main processor code v2020 robots
** motor2019: individual motor controller code v2020 robots
** libs: shared code, used by multiple applications
*** chibios: ChibiOS operating system files, used by v2016, v2020, bs2018
*** cmsis_core: Common Microcontroller Software Interface Standard files
*** common: shared code of all microcontrollers
*** dsp: external CMSIS DSP library, contains optimized matrix operations
*** fatfs: Elm Chan's FAT file system library
*** gui: shared GUI elements
*** robot: *Primary robot control code*
*** ugfx: uGFX graphics library used for touch screens
*** usb: USB client and host drivers
*** util: Utility functions, algorithms, drivers
*** f0xx: STM32F0 shared code
*** f7xx: STM32F7 shared code
*** h7xx: STM32H7 shared code
* cmake: CMake files
* deploy: boiler plate files for deploy CI pipeline
* doc: documentation folder
* docker: automated build pipeline configuration
* launch: Eclipse launch files for flashing and debugging
* openocd: OpenOCD configuration files
* protoc: ProtoBuf files used by base station
* scripts: utility scripts
** logAnalyzer: MATLAB logfile analyzer for low-level control analysis
 

== Coding style

* `small_file_names.h` and `small_file_names.c`
* Global functions use `CamelCase()`
* Global function names start with file name: `SmallFileNamesExample()`
* Local functions begin with a small first letter: `camelCase()`
* Local functions are *always* static
* Structs use `CamelCase`
* Global structs match file name: `SmallFileNames`
* I.e. only one global struct is allowed per file, use sub-structs if needed
* Variables use `camelCase`
* Pointers are pre-fixed with a 'p': `void* pIAmAPointer`
* `#define ALL_UPPER_CASE 42`
* Use fixed-size types, i.e. `int32_t`, *not* `int`
* Use english language for all structs, variables, comments, and functions
* Braces are always on next line:
+
```C
void MyFunction()
{
}
```
+
* Braces may be omitted for simple single-line blocks
+
```C
if(42)
  printQuestion();
``` 
+
* Use tab to indent

== Task 1 - Talk to me

Your first task will familiarize you with the robot's command line interface.

=== Connect
Open a terminal program of your choice to connect to the robot's serial port.
PuTTy is a good choice for Linux and Windows.
Under Linux use e.g. ttyUSB0 to connect.
Under Windows use e.g. COM1 to connect.
Actual ports to use can also vary slightly.
Connection settings are a baudrate of 921600, 8 data bits, 1 stop bit, no parity (8N1).

=== First command
Type `version` at the open terminal window and hit enter.
If everything works, the robot will greet you with its firmware version number.

=== Add a new command
* Open the `cli.c` file for your robot (src/main2019/cli.c).   
* Scroll down to the `processCommand()` function
* Add your own command there with
+
[source,C,linenums]
----
if(ConsoleCmpCmd("explode"))
{
  ConsolePrint("BUMM!\r\n");
}
----
+

You have just met another important function, `ConsolePrint`.
It outputs data on the console interface. Note that you manually have to add carriage return ('\r') and new line ('\n').

Now select in the top menu Run => Run Configurations.. => Flash MB 2019 (Run) and click on Run.
Alternatively, select the little arrow next the the green button with the play triangle and select the run configuration.
This will automatically trigger a build and flash the code to the robot.

Now enter `explode` into the console window see what happens.

=== Parse command arguments
Add another command:
[source,C,linenums]
----
int16_t i16;
if(ConsoleScanCmd("pin %hd", &i16) == 1)
{
  ConsolePrint("You entered PIN: %hd\r\n", i16);
}
----

If you want to input parameters a simple command compare is not enough.
You have to use ConsoleScanCmd which uses scanf style input. Note two things:

* The variable placeholder is 'hd', for a 'half'-sized (i.e. 16bit) datatype which is signed ('d').
  Be extremely careful to select the correct placeholder for your argument type of things may go really wrong.
* `ConsoleScanCmd` returns a value which is equal to the number of parsed variables.
  Always make sure to check the return value for the number of variables you expect.
  
TIP: Use `ConsoleScanCmd` and `ConsoleCmpCmd` only in cli.c. It does not work anywhere else!

WARNING: `ConsolePrint` requires a large thread stack and is extremely slow. Do not use for high-frequency output.

== Task 2 - Understand bot skills
Sorry, this chapter is a bit theoretic but super duper important!

=== Bot skill structure
Each skill has:

* An input structure. This is the data input for the skill from Sumatra.
  This input structure is also present in Sumatra (check moduli-botmanager).
* A `SkillInstance` global variable
* A `run` function, executed at 1000Hz.
* Optionally an init and exit function, called once upon starting or stopping the skill.

Go to `src/libs/robot` and have a look at `skill_sine.h` and `skill_sine.c` for a good and simple example.
Go through the code and try to locate the above mentioned points. Can you find out what this skill does?

=== Input data
A bot skill has access to various input sources to perform its task. Have a look at the follwing diagram: 
[ditaa]
----
Sumatra Data +------+
                    |
Sensors +-------+   |
                |   |
                v   v
            +---+-------+
State +---->+ Bot Skill +--->Skill Output+--->Control Algorithm
            +--+-----+--+        +                   +
               ^     ^           |                   |
               |     |           |                   |
               |     +-----------+                   |
               |        delay                        |
               |                                     |
               +-------------------------------------+
                        Trajectory Data
----
Data sources are:

* Sumatra Data: As mentioned before, this is skill-dependent data from Sumatra
* Sensors: Contains data from all sensors the robot can access (e.g. encoders, gyros, vision, battery, motors, IR barrier).
* State: Current robot state (position, velocity, acceleration) combined by the robot's sensor fusion.
* Skill Output: The last output from the previous run of the skill is available as input.
* Trajectory Data: This contains the planned 'path' the robot intents to take, with setpoints for position, velocity and acceleration.

You can check the `SkillInput` structure and its members for details.

=== Output data
The skill output contains:

* Input data for the drive system. 
  This can be a position, local velocity, force, or motor velocities together with their limits.
  The control algorithm will take care of going from A to B while respecting limits as good as possible.
  A bot skill does not need to worry about control theory (too much).
* Desired dribbler speed/force and mode. Can be a controlled velocity or an open-loop voltage.
* Kicker control data. Allows to arm/disarm the kicker, select the kick device and kick speed.

== Task 3 - Run a simple bot skill
Have a look at `skill_kick_ball.h` and `skill_kick_ball.c` in `src/libs/robot`.
This skill is planned to kick the ball to a target position.
So far it only slowly turns counter-clockwise in place when started.

=== Start bot skill
WARNING: Depending on your last Sumatra state, the robot may automatically charge its capacitors to a high voltage.
If the red capacitor light is on please press F6 in Sumatra to auto-discharge.

We will now start this simple skill for the first time.
Open Sumatra and connect to your base station. 
Make sure your base station is on a distinct channel and your robot is connected to it.

HINT: When desk-testing with a robot please make sure to place something under it, so that the wheels are in the air.
If your robot plays havoc due to some bug it can't go anywhere this way.
 
To start the new skill:

* Open the Skills view
* Resize the panel to be able to see all options, this panel does not use a scrollbar
* Choose your robot in the upper drop-down list
* In the rightmost drop-down list select KICK_BALL
* Ignore all the possible parameters for now
* Click on Create below all the parameter boxes

Your robot shall now start to turn slowly, because it executes the sample kick ball skill. 
If not, please call for assistance.

=== Sumatra backend
For this workshop, the bot skill counterpart in Sumatra has already been created for you.
Just search for `BotSkillKickBall` to see how it looks like in Sumatra to create the bot skill input structure.
Keep in mind that this counterpart in Sumatra is not created or updated automatically.
If you change something on the skill input structure in the Firmware, you must adapt it in Sumatra as well.

Bot skills are very basic functions which extend what the robot can actually do.
They are executed within the robots primary control task, so you can really mess things up here.

=== Make a small modification
To make sure your code changes actually change the behavior of the bot skill, try to edit the rotation velocity
in the `run(..)` function in `skill_kick_ball.c`. Locate the line with `pOutput->drive.localVel[2]` and
try a negative velocity. Compile and flash the code. Start the bot skill again from Sumatra. The robot should now turn
the other direction.

== Task 4 - Move to the ball
You will now continuously extend the bot skill code until it finally kicks the ball to a target.
A good first step to actually kick the ball is to get close to it.

=== Skill input data
Bot skll data from Sumatra to the robot usually has very strange units to make best use of the only 16 available bytes
for bot skill input. Luckily, for the kick ball bot skill this has already been done. Input is translated to SI units
and put to the `skillKickBall` global variable. This includes ball position, target position, and the field size.

=== Use global position mode
Change the `run(..)` function:

* Set the `drive.mode` output variables to `DRIVE_MODE_GLOBAL_POS`.
* Use `drive.pos` fields instead of `drive.localVel`.
* Set `drive.pos[0]` and `drive.pos[1]` to the ball position from `skillKickBall.ballPos`.
* Set `drive.pos[2]` to zero for a fixed orientation.
* Ensure the robot does not attempt to move out of field bounds. Use the `Clampf` function on `drive.pos` (X and Y) with `skillKickBall.fieldHalfSize` as limit.

=== Run changed bot skill
HINT: You need to be at the field now with a working and connected SSL Vision.

WARNING: When testing at the field please have a person near the field ready to sprint and catch the robot
in case something goes wrong. Furthermore, if your robot freaks out, hit ESC immediately on the computer running Sumatra.
This will trigger an emergency stop on all robots.

Flash your code to the robot and test it with the `BotSkillKickBall`. You now need to set the `ballPos` and `fieldSize` parameters, they are in millimeters.
Furthermore, you need to set the movement limits (vel/acc).
You do not need a real ball on the field yet.

Test the following functions:
* The robot should move to the position entered at `ballPos`
* The robot should keep a fixed orientation
* Try a ball position outside the fieldSize, the robot should only move to the boundary
* Try different movement limits to see how this affects robot movement.

=== Test it more
So far, we have manually entered data about the ball position and field size. 
This is not very effective in case we have a real ball on the field.
Luckily, somebody already created a skill in Sumatra which:

* Takes the field size from the SSL Vision geometry and
* Uses the current ball position from Sumatra's vision filter and
* Creates a `BotSkillKickBall` and puts in these two values
* It also puts in the the movement limits from Sumatra's BotParams panel

To use this awesome skill, stay in the Skills View but now use the drop-down next to the colorful crosshair (a.k.a. Ultra-Panel).
There is an entry called just `BOT_LOCAL_KICK`. Select it, put a real ball on the field and click Create.

The robot should now continuously try to move onto the ball, as its destination is the moving ball. Hit ESC when done.

== Task 5 - Dribble and Kick
It is your goal now to extend the bot skill to actually kick to the target. You should keep a few things in mind:

* You need to line up bot and ball to face the target
** You may either move around the ball to line up or
** Go directly for the ball, use the dribbler, and rotate with the ball
** One is faster and mayber easier to implement, the other one is more reliable and might be more precise
* If you want to move around the ball, respect field boundaries and use intermediate targets
* You don't need to fully stop to change the drive target position, it can be changed at any time
* Specify dribble and kick parameters in Sumatra, overwrite them in the bot skill if needed (`pOutput->dribbler` and `pOutput->kicker`)
* Be very careful when testing actual kicks!
* Do not use chip kicks if you are not ready to catch balls flying off the field!

=== Dribbling
Dribbler output values are in `pOutput->dribbler`. If you want to dribble set `mode` to `DRIBBLER_MODE_SPEED`.
Specify a dribbling bar surface speed and force (good starting values are 3m/s and 3N).
To stop dribbling set `velocity` to zero (uses a controlled spin-down) or set `mode` to `DRIBBLER_MODE_OFF` (immediate stop).

It is recommended not to hard-code values in the bot skill. Use values from Sumatra. You may overwrite the `velocity` value from Sumatra to stop dribbling
as long as you don't need it.

=== Kicking
Kicker output values are in `pOutput->kicker`. To enable/disable the kicker set `mode` to `KICKER_MODE_ARM` or `KICKER_MODE_DISARM`.
If armed, the robot will kick as soon as it has ball contact. Kick speed and device may be set as well, but it is best to keep it
at the values taken from Sumatra.

Always overwrite the kicker mode to disarm as long as you don't want the robot to kick.

=== Additional hints
A few more hints to start your bot skill journey:

* Make sure to always set outputs for drive system, kicker, and dribbler. Otherwise the robot may still use data from the skill which executed before.
* The bot skill input struct also contains all sensors, states, and control references.
** You can find the current robot position in the state.
** The dribbling state and strength can also be found in the state.
* There is a global variable named `botParams` which contains physical parameters of the robot.
* Check the included utility headers. There are helper functions for angle math, vector/line math, and many more tools.

== Task 6 - Technical Challenge
In this challenge, your bot skill is evaluated based on the following metric.
Within a trial, all points can only be scored once. A trial lasts a maximum of 30s.
In case of a tie, the faster time is better.

|===
|Action | Points

|Stay within field bounds all the time
|+1

|Touch ball with any part of the robot
|+1

|Touch ball with dribbler
|+1

|Kick the ball
|+1

|Hit the target with a max. deviation of 10cm
|+1

|Hit the target with a max. deviation of 3cm
|+2

|===